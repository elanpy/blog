---
title: 理解动态规划
top_img: 'http://tva1.sinaimg.cn/large/008lIB40ly1h6xrw53t51j31kw0w0hdt.jpg'
cover: 'http://tva1.sinaimg.cn/large/008lIB40ly1h6xrw53t51j31kw0w0hdt.jpg'
abbrlink: f8c8bd2a
date: 2022-10-10 09:18:36
tags:
---
转载于https://juejin.cn/post/6951922898638471181#heading-16

## 本文大纲

![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6xtv20jprj31f00yek27.jpg)

## 什么是动态规划

[动态规划](https://zh.m.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)（英语:Dynamic programming，简称
DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。

> dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.

以上定义来自维基百科，看定义感觉还是有点抽象。简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决。然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。

> 一般这些子问题很相似，可以通过函数关系式递推出来。然后呢，动态规划就致力于解决每个子问题一次，减少重复计算，比如斐波那契数列就可以看做入门级的经典动态规划问题。

## 动态规划核心思想

动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算.

我们来看下，网上比较流行的一个例子:

> - A : "1+1+1+1+1+1+1+1 =？"
> - A : "上面等式的值是多少"
> - B : 计算 "8"
> - A : 在上面等式的左边写上 "1+" 呢？
> - A : "此时等式的值为多少"
> - B : 很快得出答案 "9"
> - A : "你怎么这么快就知道答案了"
> - A : "只要在8的基础上加1就行了"
> - A : "所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"

## 一个例子走进动态规划(70. 爬楼梯)

### 暴力递归

> leetcode原题:
>
> > 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
> > 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

有些小伙伴第一次见这个题的时候，可能会有点蒙圈，不知道怎么解决。其实可以试想:

> - 要想爬到第10级台阶，要么是先爬到第9级，然后再爬1级台阶上去;要么是先爬到第8级，然后一次迈2级台阶上去。
>
> - 同理，要想爬到第9级台阶，要么是先爬到第8级，然后再爬1级台阶上去;要么是先爬到第7级，然后一次迈2级台阶上去。
>
> - 要想爬到第8级台阶，要么是先爬到第7级，然后再爬1级台阶上去;要么是先爬到第6级，然后一次迈2级台阶上去。

假设爬到第n级台阶的方法数我们定义为f(n)，很显然就可以得出以下公式:

```
f（10） = f（9）+f(8)
f (9)  = f(8) + f(7)
f (8)  = f(7) + f(6)
...
f(3) = f(2) + f(1)

即通用公式为: f(n) = f(n-1) + f(n-2)
```

那f(2) 或者 f(1) 等于多少呢？

- 当只有2级台阶时，有两种走法，第一种是直接走两级，第二种是先走一级，然后再走一级。即f(2) = 2;
- 当只有1级台阶时，只有一种走法，即f（1）= 1；

因此可以用递归去解决这个问题:

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        return self.climbStairs(n - 1) + self.climbStairs(n - 2)
```

去leetcode提交一下，发现有问题，超出时间限制了

![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6xu9e9bxfj30fa05ogm0.jpg)

为什么超时了呢？递归耗时在哪里呢？我们将代码放到pycharm里运行，并查看一下总耗时:

![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6ysmlj7gyj30ed0bk0ut.jpg)

这个运行时间不超时才怪呢，那么接下来要分析为什么耗时这么久，画出**递归树**看一下:

![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6yt16msa5j31980wwn1r.jpg)

![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6yt2s7eqlj31do0vgk5s.jpg)

- 如果计算原问题f(10)，就需要，就需要先计算出子问题f(9)和f(8)
- 然后要计算f(9)，又要先计算出子问题f(8)和f(7)，以此类推
- 一直到f(2)和f(1)，递归树才到最底层。

我们看一下这个递归的时间复杂度吧:

```bash
递归时间复杂度 = 解决一个子问题时间 * 子问题个数
```

> 解决一个子问题时间 = f(n - 1) + f(n - 2)，也就是一个加法的操作，所以复杂度是O(1)；
> 子问题个数 = 递归树节点的总数，递归树总节点 = 2^n - 1，所以复杂度为O(2^n)。

因此该问题递归解法的时间复杂度 = O(1) * O(2^n) = O(2^n)，也就是指数界别，爆炸型增长趋势，如果n较大的话，超时也是很正常的。

我们在看一下上面两个递归树可视化图形中，会发现其中有大量的节点存在着重复计算，并且随着n的增加，重复节点也不断增加，所以这个递归算法低效的原因也就是**存在大量重复计算！**

既然存在大量重复计算，那么我们可以先把计算好的答案存下来，即造一个备忘录，等到下次需要的话，先去备忘录查一下，如果有，就直接取就好了，备忘录没有才开始计算，那就可以省去重新重复计算的耗时啦！这就是带备忘录的解法。

### 带备忘录的递归解法(自上而下)

一般使用一个数组或者一个哈希map充当这个备忘录，在python里我们使用一个空字典充当备忘录

- 第一步，f(10)=f(9)+f(8)，f(9)和f(8)都需要计算出来，然后再加到备忘录中，如下:
  ![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6yumelchgj30uo0b075i.jpg)

- 第二步， f(9)=f(8)+f(7)， f(8)=f(7)+f(6), 因为f(8)已经在备忘录中啦，所以可以省掉，f(7)，f(6)都需要计算出来，加到备忘录中~
  ![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6yv7ikbisj313s0h6jun.jpg)

以此类推，我们将所有计算过的节点都放入备忘录，等到下次遇到相同的就可以省去重复计算，直接从备忘录里取结果就可以了

所以，用了备忘录递归算法，递归树变成光秃秃的树干，如下:
![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6yvwnxbhfj31gq0bw0up.jpg)
带备忘录的递归算法，子问题个数 = 树节点数 = n，解决一个子问题还是O(1),所以带备忘录的递归算法的时间复杂度是O(n)。接下来呢，我们用带备忘录的递归算法去撸代码，解决这个爬台阶问题的超时问题，代码如下:

```python
class Solution:
    cache_dict = {}

    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        if n in self.cache_dict:
            return self.cache_dict.get(n)
        else:
            self.cache_dict[n] = self.climbStairs(n - 1) + self.climbStairs(n - 2)
            return self.cache_dict[n]
```

去leetcode提交一下，如图

![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6yxf4lbwlj32880icgu4.jpg)

以上我们使用了带备忘录的递归解决了这道题，那么其实也可以用动态规划来解决

### 自下而上的动态规划

动态规划跟带备忘录的递归解法基本思想是一致的，都是减少重复计算，时间复杂度也都是差不多。但是呢

- 带备忘录的递归，是从f(10)往f(1)方向延伸求解的，所以也称为**自上而下**的解法。
- 动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，它是从f(1)往f(10)方向，往上推求解，所以称为**自下而上**的解法。

动态规划有几个典型特征，**最优子结构、状态转移方程、边界、重叠子问题**。在爬楼梯问题中:

- f(n-1)和f(n-2) 称为f(n)的最优子结构
- f(n)=f(n-1)+f(n-2) 就称为状态转移方程
- f(1)=1， f(2)=2 就是边界
- 比如f(10)=f(9)+f(8)， f(9)=f(8)+f(7) 这两个节点计算中f(8)就是重叠子问题

我们看一下**自下而上**的解法，从f(1)向f(10)方向，想一下就是一个for循环即可搞定，如下:

![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6yzgasb8gj319w0d4q58.jpg)

带备忘录的递归解法，空间复杂度是O(n)，但是呢，仔细观察上图，可以发现，f(n)只依赖前面两个数，所以只需要两个变量a和b来存储，就可以满足需求了，因此空间复杂度是O(1)就可以啦

![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6yznxx6fcj319o0g6ad1.jpg)

动态规划代码实现如下:

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        a = 1
        b = 2
        for i in range(3, n + 1):
            a, b = b, a + b
        return b
```

LeetCode提交结果如下:
![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6yzuevzruj31sy0fmq8e.jpg)

## 动态规划的解题思路

### 什么样的问题可以考虑使用动态规划解决

> 如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。

比如一些求最值的场景，如**最长递增子序列、最小编辑距离、背包问题、凑零钱问题**等等，都是动态规划的经典应用场景。

### 动态规划的解题思路

动态规划的核心思想就是**拆分子问题，记住过往，减少重复计算**。 并且动态规划一般都是自下而上的，因此到这里，基于**爬台阶**问题，我总结了一下我做动态规划的思路:

- 穷举分析
- 确定边界
- 找出规律，确定最优子结构
- 写出状态转移方程

#### 穷举分析

- 当台阶数是1的时候，有一种走法，f(1)=1
- 当只有2级台阶时，有两种走法，第一种是直接走两级，第二种是先走一级，然后再走一级。即f(2)=2；
- 当有3级台阶时，想走到第3级台阶，要么先走到第2级，然后再走1级台阶上去,要么先走到第1级台阶，然后一次迈2级台阶上去。所以f(3) = f(2)+f(1) = 3
- 当有4级台阶时，想走到第4级台阶，要么先走到第3级，然后走1级到第4级，要么先走到第2级，一次迈2级台阶上去。所以f(4) = f(3)+f(2) = 5
- 以此类推

#### 确定边界

通过穷举分析，我们发现当台阶数是1或者2的时候，可以明确知道有多少种走法。f(1)=1，f(2)=2，当台阶n≥3时，已经可以呈现出f(3)=f(2)+f(1)的规律，因此f(1)=1，f(2)=2就是该问题的边界。

#### 找规律，确定最优子结构

n≥3时，已经呈现出规律f(n) = f(n-1)+f(n-2)，因此f(n-1)和f(n-2)称为f(n)的最优子结构。那么什么时最优子结构呢？有这么一个解释:
> 一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质

#### 写出状态转移方程

通过前面3个步骤，穷举分析、确定边界、最优子结构，我们就可以得出状态转移方程:
![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6z1xdltl8j31j60kin0p.jpg)

## LeetCode案例分析

接下来分析另外一道LeetCode案例
> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例1:
> **输入**:nums = [10,9,2,5,3,7,101,18]
> **输出**:4
> **解释**:最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例2:
> **输入**:nums = [0,1,0,3,2,3]
> **输出**:4

示例3:
> **输入**:nums = [7,7,7,7,7,7,7]
> **输出**:1

我们按照以上动态规划的解题思路:

- 穷举分析
- 确定边界
- 找规律，确定最优子结构
- 状态转移方程

### 穷举分析

因为动态规划，核心思想包括**拆分子问题，记住过往（建立备忘录），减少重复计算**。所以我们在思考原问题:**数组num[i]的最长递增子序列长度**时，可以思考一下**相关子问题**，比如原问题是否跟**子问题**num[i-1]
的最长递增子序列长度有关呢？

#### 自下而上的穷举

这里观察规律，显然是有关系的，我们还是遵循动态规划**自下而上**的原则，基于示例1的数据（[10, 9, 2, 5, 3, 7, 101, 18]），从数组只有一个元素开始分析。

- [10]，当nums只有一个元素10时，最长递增子序列是[10]，此时长度为1
- [10, 9]，当nums添加一个元素9时，最长递增子序列是[10]或[9]，此时长度为1
- [10, 9, 2]，当nums添加一个元素2时，最长递增子序列是[10]或[9]或[2]，此时长度为1
- [10, 9, 2, 5]，当nums添加一个元素5时，最长递增子序列是[2, 5]，此时长度为2
- [10, 9, 2, 5, 3]，当nums添加一个元素3时，最长递增子序列是[2, 5]或[2, 3]，此时长度为2
- [10, 9, 2, 5, 3, 7]，当nums添加一个元素7时，最长递增子序列是[2, 5, 7]或[2, 3, 7]，此时长度为3
- [10, 9, 2, 5, 3, 7, 101]，当nums添加一个元素101时，最长递增子序列是[2, 5, 7, 101]或[2, 3, 7, 101]，此时长度为4
- [10, 9, 2, 5, 3, 7, 101, 18]，当nums添加一个元素18时，最长递增子序列是[2, 5, 7, 101]或[2, 3, 7, 101]或[2, 5, 7, 18]或[2, 3, 7, 18]，此时长度为4

#### 分析找规律，拆分子问题
通过上面的穷举分析，我们可以发现一个规律:
如果新加入一个元素nums[i], 最长递增子序列要么是**以nums[i]结尾的递增子序列**，要么就**是nums[i-1]的最长递增子序列**。看到这个，是不是很开心，nums[i]的最长递增子序列已经跟子问题 nums[i-1]的最长递增子序列有关联了。
> 原问题数组nums[i]的最长递增子序列 = max(子问题数组nums[i-1]结尾的最长递增子序列，子问题数组nums[i]结尾的最长递增子序列)

是不是感觉成功了一半呢？但是**如何把nums[i]结尾的递增子序列也转化为对应的子问题**呢？要是nums[i]结尾的递增子序列也跟nums[i-1]的最长递增子序列有关就好了。又或者nums[i]结尾的最长递增子序列，跟前面子问题num[i-2]结尾的最长递增子序列有关就好了，带着这个想法，我们又回头看看穷举的过程:
![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6z43ligzvj31760g4wnd.jpg)

nums[i]的最长递增子序列，不就是**从以数组num[i]每个元素结尾的最长子序列集合，取元素最多（也就是长度最长）那个**嘛，所以原问题，我们转化成求出以数组nums每个元素结尾的最长子序列集合，再**取最大值**嘛。哈哈，想到这，我们就可以用**dp[i]表示以num[i]这个数结尾的最长递增子序列的长度**啦，然后再来看看其中的规律:

![image.png](http://tva1.sinaimg.cn/large/008lIB40ly1h6z3ktwopgj31900b0wfo.jpg)
其实，**nums[i]结尾的自增子序列，只要找到比nums[i]小的子序列，加上nums[i]**就可以啦。显然，可能形成多种新的子序列，我们选最长那个，就是dp[i]的值啦
> - nums[3]=5，从数组下标`0到3`遍历，只找到了子序列`[2]`比`5`小，所以就是`[2]+[5]`，此时以5结尾的最长子增子序列为`[2, 5]`，即`dp(3)=2`
> - nums[4]=3，从数组下标`0到4`遍历，只找到了子序列`[2]`比`3`小，所以就是`[2]+[3]`，此时以5结尾的最长子增子序列为`[2, 3]`，即`dp(4)=2`
> - nums[5]=7，从数组下标`0到5`遍历，找到了`2、5和3`都比`7`小，所以就有`[2,7],[5,7],[3,7],[2,5,7]和[2,3,7]`这些子序列，最长子序列就是`[2,5,7]和[2,3,7]`，他俩就是以`5`结尾和`3`结尾的最长递增子序列+[7]得来的。所以`dp(5) = dp(3)+1 = dp(4)+1 = 3`

很显然有这个规律：一个以nums[i]结尾的数组nums
- 如果存在j属于区间[0，i-1],并且`num[i]>num[j]`的话，则有，dp(i) = max(dp(j))+1，

### 确定边界

当nums数组只有一个元素时，最长递增子序列的长度dp(1)=1,当nums数组有两个元素时，dp(2)= 2或者1， 因此边界就是dp(1)=1。

### 确定最优子结构
从穷举分析，我们可以得出，以下的最优结构：
```
dp(i) = max(dp(j))+1，存在j属于区间[0，i-1],并且num[i]>num[j]。
```
**max(dp(j))**就是最优子结构。

### 状态转移方程
通过前面分析，我们就可以得出以下状态转移方程：
![image.png](http://tva1.sinaimg.cn/mw690/008lIB40ly1h6zz3i3sfhj312007o0u0.jpg)
所以数组num[i]的最长递增子序列就是：
```
最长递增子序列 =max (dp[i])
```
代码实现如下：
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        dp = [1] * len(nums)
        max_value = 0
        for i_index, i_value in enumerate(nums[1:], start=1):
            for j_index, j_value in enumerate(nums[:i_index]):
                if j_value < i_value:
                    dp[i_index] = max(dp[i_index], dp[j_index] + 1)

            max_value = max(max_value, dp[i_index])
        return max_value
```